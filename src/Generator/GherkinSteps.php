<?php

namespace tad\Codeception\Command\Generator;


use Codeception\Lib\Di;
use Codeception\Lib\ModuleContainer;
use Codeception\Util\Template;
use phpDocumentor\Reflection\DocBlock;
use phpDocumentor\Reflection\DocBlock\Tags\Generic;
use phpDocumentor\Reflection\DocBlockFactory;

class GherkinSteps
{
    protected $template = <<<EOF
<?php  //[STAMP] {{hash}}
namespace {{namespace}}_generated;

// This class was automatically generated by the steppify task
// You should not change it manually as it will be overwritten on next steppify run
// @codingStandardsIgnoreFile

trait {{name}}GherkinSteps{{postfix}}
{

    {{methods}}
}

EOF;

    protected $conversionTemplate = <<< EOF
        \$args = steppify_convertTableNodesToArrays(func_get_args(), \$iterations);

        if(!empty(\$iterations)) {
            \$returnValues = [];
            foreach(\$iterations as \$iteration){
                \$returnValues[] = call_user_func_array([\$this,"{{method}}"],\$iteration);
            }

            return \$returnValues;
        }

EOF;

    protected $methodTemplate = <<<EOF
    /**
     * [!] Method is generated from steppify task. Documentation taken from corresponding module.
     *
     {{gherkinDoc}}
     *
     * @see \{{module}}::{{method}}()
     */
    public function {{action}}({{params}}) {
        {{argsConversion}}
        return call_user_func_array([\$this,"{{method}}"],\$args);
    }
EOF;

    protected $stopWords = ['see', 'have', 'and', 'or', 'with', 'to', 'in', 'on'];
    protected $jumpingStopWords = ['see', 'have', 'with', 'in', 'on'];

    /**
     * @var string
     */
    protected $module;

    /**
     * @var array
     */
    protected $settings;

    /**
     * @var Di
     */
    protected $di;

    /**
     * @var ModuleContainer
     */
    protected $moduleContainer;

    /**
     * @var array
     */
    protected $actions;

    /**
     * @var array
     */
    protected $currentMethodConfig;

    public function __construct($module, array $settings = [])
    {
        $this->settings = $settings;
        $this->module = $module;

        $ref = new \ReflectionClass($module);

        $publicMethods = $ref->getMethods(\ReflectionMethod::IS_PUBLIC);

        $this->actions = array_filter(array_map(function (\ReflectionMethod $method) {
            return preg_match('/^_/', $method->getName()) ?
                false : $method->getName();
        }, $publicMethods));
    }

    /**
     * @return string
     */
    public function produce()
    {
        $namespace = rtrim($this->settings['namespace'], '\\');


        $this->settings = $this->normalizeModuleSettings($this->settings);
        $this->settings = $this->fullyQualifyModuleNames($this->settings);

        return (new Template($this->template))
            ->place('hash', $this->generateHash())
            ->place('namespace', $namespace ? $namespace . '\\' : '')
            ->place('name', ucfirst($this->settings['name']))
            ->place('postfix', $this->settings['postfix'])
            ->place('methods', $this->getMethods())
            ->produce();
    }

    protected function normalizeModuleSettings(array $settings)
    {
        if (empty($settings['steps-config']['modules'])) {
            return $settings;
        }

        $normalized = [];
        foreach ($settings['steps-config']['modules'] as $key => $value) {
            $normalized['\\' . trim($key, '\\')] = $value;
        }

        $settings['steps-config']['modules'] = $normalized;

        return $settings;
    }

    protected function fullyQualifyModuleNames(array $settings)
    {
        if (empty($settings['steps-config']['modules'])) {
            return $settings;
        }

        $modules = $settings['steps-config']['modules'];
        $settings['steps-config']['modules'] = [];
        foreach ($modules as $module => $moduleConfig) {
            if (class_exists('\\Codeception\\Module' . $module)) {
                $module = '\\Codeception\\Module' . $module;
            }
            $settings['steps-config']['modules'][$module] = $moduleConfig;
        }

        return $settings;
    }

    protected function generateHash()
    {
        return (md5(serialize($this->module) . serialize($this->settings)));
    }

    /**
     * @return string
     * @gherkin given, when, then
     */
    protected function getMethods()
    {
        // generate the method template
        $methods = [];
        foreach ($this->actions as $method) {

            if ($this->shouldSkipMethod($this->module, $method)) {
                continue;
            }

            $methods[] = (new Template($this->methodTemplate))
                ->place('module', ltrim($this->module, '\\'))
                ->place('method', $method)
                ->place('argsConversion', $this->getArgsConversion($this->module, $method))
                ->place('gherkinDoc', $this->getGherkingDoc($this->module, $method))
                ->place('action', 'step_' . $method)
                ->place('params', $this->getParams($this->module, $method))
                ->produce();
        }

        return implode(PHP_EOL . PHP_EOL, $methods);
    }

    protected function shouldSkipMethod($module, $method)
    {

        $module = '\\' . trim($module, '\\');

        $configSkipped = !empty($this->settings['steps-config']['modules'][$module]['exclude']) ?
            (array)$this->settings['steps-config']['modules'][$module]['exclude']
            : [];

        if (in_array($method, $configSkipped)) {
            return true;
        }

        $docBlockFactory = DocBlockFactory::createInstance();
        $docBlock = (new \ReflectionMethod($module, $method))->getDocComment();

        if (empty($docBlock)) {
            return false;
        }

        $docBlock = $docBlockFactory->create($docBlock);
        $gherkinTags = $docBlock->getTagsByName('gherkin');

        if (empty($gherkinTags)) {
            return false;
        }

        /** @var Generic $tag */
        $tag = $gherkinTags[0];
        return preg_match('/(N|n)(o|O)/', $tag->getDescription()->render());
    }

    protected function getArgsConversion($module, $method)
    {
        $method = new \ReflectionMethod($module, $method);
        $parameters = $method->getParameters();
        $convert = count(array_filter($parameters, function (\ReflectionParameter $p) {
                return $p->isArray();
            })) > 0;

        return $convert ? $this->conversionTemplate : '$args = func_get_args();';
    }

    /**
     * @param string $module
     * @param \ReflectionMethod $method
     *
     * @return string
     */
    protected function getGherkingDoc($module, $method)
    {
        $docBlockFactory = DocBlockFactory::createInstance();
        $reflectionMethod = new \ReflectionMethod($module, $method);
        $docComment = $reflectionMethod->getDocComment();

        if (preg_match('/@(Giv|Wh|Th)en\\s/', $docComment)) {
            $frags = explode(PHP_EOL, $docComment);
            return implode(PHP_EOL, array_filter($frags, function ($line) {
                return preg_match('/@(Giv|Wh|Th)en\\s/', $line);
            }));
        }

        $module = '\\' . trim($module, '\\');

        $methodConfig = !empty($this->settings['steps-config']['modules'][$module]['methods'][$method]) ?
            $this->settings['steps-config']['modules'][$module]['methods'][$method] :
            [];

        if (empty($methodConfig['generates'])) {
            $steps = $this->getStepsFromMethodDocBlock($docComment, $docBlockFactory);
        } else {
            $steps = $methodConfig['generates'];
        }

        return $this->generateGherkinStepsNotations($steps, $module, $method, $methodConfig);
    }

    /**
     * @param string $docComment
     * @param DocBlockFactory $docBlockFactory
     * @return array
     */
    protected function getStepsFromMethodDocBlock($docComment, $docBlockFactory)
    {
        $steps = ['given', 'when', 'then'];

        if (!empty($docComment)) {
            /** @var DocBlock $docBlock */
            $docBlock = $docBlockFactory->create($docComment);
            $gherkinTags = $docBlock->getTagsByName('gherkin');

            if (!empty($gherkinTags)) {
                /** @var Generic $gherkingTag */
                $gherkingTag = reset($gherkinTags);
                $steps = preg_split('/\\s*,\\s*/', $gherkingTag->getDescription()->render());
                return $steps;
            }
            return $steps;
        }
        return $steps;
    }

    /**
     * @param array $steps
     * @param string $module
     * @param \ReflectionMethod $method
     * @param array $methodConfig
     *
     * @return string
     */
    protected function generateGherkinStepsNotations(array $steps, $module, $method, array $methodConfig)
    {
        $ref = new \ReflectionMethod($module, $method);
        $parameters = $ref->getParameters();

        $lines = $this->getGherkinNotationLinesFor($method, $parameters, $steps, $methodConfig);

        $doc = implode(PHP_EOL . "\t ", $lines);

        return $doc;
    }

    /**
     * @param \ReflectionMethod $method
     * @param \ReflectionParameter[] $parameters
     * @param array $steps
     *
     * @return array
     */
    protected function getGherkinNotationLinesFor($method, $parameters, $steps, array $methodConfig)
    {
        $parameterNames = $this->extractParameterNames($parameters);

        if (!empty($methodConfig['step'])) {
            $lines = [];
            $generates = (array)$methodConfig['generates'];
            array_walk($generates, function ($generatedStep) use ($methodConfig, &$lines) {
                $stepLines = array_map(function ($stepTemplate) use ($generatedStep) {
                    return '* @' . ucfirst($generatedStep) . ' ' . $stepTemplate;
                }, (array)$methodConfig['step']);
                $lines = array_merge($lines, $stepLines);
            });
        } else {
            $wordsWithoutStopwords = $words = array_map('strtolower', preg_split('/(?=[A-Z_])/', $method));
            $parameterNamesAndStopwords = $this->extractParameterNamesAndStopWords($words, $parameterNames,
                $wordsWithoutStopwords);
            $lines = $this->buildGherkinLinesForSteps($steps, $parameters, $wordsWithoutStopwords,
                $parameterNamesAndStopwords);
        }

        return $lines;
    }

    /**
     * @param $parameters
     * @return array
     */
    protected function extractParameterNames($parameters)
    {
        $parameterNames = [];
        if (!empty($parameters)) {
            $parameterNames = array_map(function (\ReflectionParameter $parameter) {
                return $parameter->getName();
            }, $parameters);
            return $parameterNames;
        }
        return $parameterNames;
    }

    /**
     * @param array $words
     * @param array $parameterNames
     * @param array $wordsWithoutStopwords
     * @return array
     */
    protected function extractParameterNamesAndStopWords($words, $parameterNames, &$wordsWithoutStopwords)
    {
        $parameterNamesAndStopwords = [];
        for ($i = 0; $i < count($words); $i++) {
            if (false !== ($parameterPos = array_search($words[$i], $parameterNames))) {
                $foo = $i > 0 && in_array($words[$i - 1], $this->stopWords) ?
                    $words[$i - 1] : 'and';
                $parameterNamesAndStopwords[$parameterNames[$parameterPos]] = $foo;
                unset($wordsWithoutStopwords[$i]);
                unset($wordsWithoutStopwords[$i - 1]);
                continue;
            }
        }
        return $parameterNamesAndStopwords;
    }

    /**
     * @param array $steps
     * @param \ReflectionParameter[] $parameters
     * @param array $wordsWithoutStopwords
     * @param array $parameterNamesAndStopwords
     *
     * @return array
     */
    protected function buildGherkinLinesForSteps(
        $steps,
        $parameters,
        $wordsWithoutStopwords,
        $parameterNamesAndStopwords
    ) {
        $lines = [];
        $parameterNames = $this->extractParameterNames($parameters);
        foreach ($steps as $step) {
            $lastLineIndex = empty($lines) ? 0 : count($lines);

            $lastLine = $lines[$lastLineIndex] = sprintf('* @%s I %s', ucfirst(trim($step)),
                implode(' ', $wordsWithoutStopwords));

            foreach ($parameters as $parameter) {
                $parameterName = $parameter->getName();
                $parameterPosition = array_search($parameterName, $parameterNames);

                $stopWord = isset($parameterNamesAndStopwords[$parameterName]) ?
                    $parameterNamesAndStopwords[$parameterName]
                    : 'and';

                if (0 !== $parameterPosition ||
                    (isset($parameterNamesAndStopwords[$parameterName])
                        && in_array($parameterNamesAndStopwords[$parameterName], $this->jumpingStopWords)
                    )
                ) {
                    $stopWord = isset($parameterNamesAndStopwords[$parameterName]) ?
                        $parameterNamesAndStopwords[$parameterName]
                        : 'and';
                    $stopWordAndParameterName = $stopWord . ' ' . $parameterName;
                } elseif (!$parameter->isArray()) {
                    $stopWordAndParameterName = $parameterName;
                } else {
                    $stopWordAndParameterName = '';
                }

                if (!$parameter->isDefaultValueAvailable() || $parameter->isArray()) {
                    $lineFrags = explode(' ', $lines[$lastLineIndex]);
                    $lineLastWord = end($lineFrags);
                    if (!in_array($lineLastWord, $this->stopWords)
                        && !$parameter->isArray()
                        && $parameterPosition === 0
                        && !in_array($stopWord, $this->jumpingStopWords)
                    ) {
                        $resultLine = sprintf('%s :%s', $lines[$lastLineIndex], $parameterName);
                    } elseif (!$parameter->isArray()) {
                        $resultLine = sprintf('%s %s :%s', $lines[$lastLineIndex], $stopWordAndParameterName,
                            $parameterName);
                    } else {
                        $resultLine = $lines[$lastLineIndex];
                    }
                    $lines[$lastLineIndex] = $lastLine = $resultLine;
                } else {
                    $lastLine = sprintf('%s %s :%s', $lastLine, $stopWordAndParameterName, $parameterName);
                    $lines[] = $lastLine;
                }
            }
        }
        return $lines;
    }

    /**
     * @param string $module
     * @param string $method
     *
     * @return string
     */
    protected function getParams($module, $method)
    {
        $method = new \ReflectionMethod($module, $method);

        $params = $method->getParameters();

        if (empty($params)) {
            return '';
        }

        return implode(', ', array_map([$this, 'getEntryForParameter'], $params));
    }

    /**
     * @param \ReflectionParameter $parameter
     *
     * @return string
     */
    protected function getEntryForParameter(\ReflectionParameter $parameter)
    {
        if ($parameter->getType() && ($parameter->getType()->getName() === 'array')) {
            $type = '\Behat\Gherkin\Node\TableNode|array';
        } else {
            $class = $parameter->getClass();
            $type = empty($class) ? '' : $class->getName();
        }

        $name = $parameter->getName();
        $defaultValue = $parameter->isDefaultValueAvailable() ? $parameter->getDefaultValue() : false;

        $noDefaultValue = empty($parameter->isDefaultValueAvailable());
        if ($noDefaultValue && empty($type)) {
            return sprintf('$%s', $name);
        } elseif ($noDefaultValue) {
            return sprintf('%s $%s', $type, $name);
        } else {
            if ($defaultValue === null) {
                $defaultValue = 'null';
            } elseif (is_string($defaultValue)) {
                $defaultValue = "'" . $defaultValue . "'";
            } elseif (is_array($defaultValue)){
                $defaultValue = json_encode($defaultValue);
            }

            return sprintf('%s $%s = %s', $type, $name, $defaultValue);
        }
    }
}
